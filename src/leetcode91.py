from lib.test import *
""" 91. 解码方法

 一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：

'A' -> "1"
'B' -> "2"
...
'Z' -> "26"

要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为：

    "AAJF" ，将消息分组为 (1 1 10 6)
    "KJF" ，将消息分组为 (11 10 6)

注意，消息不能分组为  (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。

给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。

题目数据保证答案肯定是一个 32 位 的整数。 """


# #字符串 #计数 [[70]]
class Solution:
	""" 最难的是处理0， 0的位置一共有:
	1. 前导
	2. 后导
	3. 中间  
	前导 直接返回0 多个后导0或者s[-2]大于2 直接返回

	当0 出现在中间就说明需要结合前一个字符进行解码

	弄清楚这个前提之后，会发现这是一个路径计数问题，可以通过动态规划来求解。每一步的选择有两种:
	1. 使用一个字符解码
	2. 使用2个字符解码 

	f(i): i 处字符解码可能总数

	那么类似 台阶问题

	f(i)=f(i-1)+ f(i-2)

	但不同的是这个叠加是有条件的

	使用1个字符解码 if s[i]!=0: f(i)+=f(i-1)

	使用两个字符解码 则还需考虑 s[i]是否为0 如果为0 f(i)=f(i-1) elseif s[i-1]!=0 f(i)+=f(i-2)

	可以发现因为f(i)的叠加是根据if条件叠加的，所以这里就需要3个变量来分别维护 f(i) f(i-1) f(i-2)
	"""
	def numDecodings(self, s: str) -> int:
		count=0
		c_prev=1
		c_prev_prev=0
		# 为了方面处理 1020 这种情况 设置j=i+1 的位置递进一位
		for j in range(1,len(s)+1):
			count=0

			# 问题的核心是分析清楚下面两个判断的并列关系 
			# 当 case1 False case2 True 对应了 '10' 的情况即f(i)=f(i-2),当此时一定是 f(i-2)==f(i-1)  所以 结果就是 f(i)=f(i-1)
			# 当 case1 True case2 True 对应 '11' f(i)=f(i-1)+f(i-2)
			# 当 case1 False case2 False 对应 '00' f(i)=0 从这里看出每次迭代必须对 f(i) 进行初始化 否则就需要单独处理后导0的情况
			# 当 case1 True case False 对应 '1' or '54' 即 f(i)=f(i-1)


			if s[j-1]!="0":
				count+=c_prev
			if j>1 and s[j-2]!="0" and int(s[j-2]+s[j-1])<=26:
				count+=c_prev_prev
			c_prev_prev=c_prev
			c_prev=count

		return count



if __name__ == "__main__":
	s=Solution().numDecodings
	print(s("10"))

		
			
		
